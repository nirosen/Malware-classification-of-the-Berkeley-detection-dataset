import itertools
import multiprocessing as mp
import csv
import sys
import argparse
import os
import json
import pickle
import datetime
import shutil
import datetime
import multiprocessing
import time
import logging
from pathlib import Path
from symbol import continue_stmt

PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))
output_dir_path_Path = Path(PROJECT_ROOT, "output")
syscalls_dir_path_Path = Path(PROJECT_ROOT, "vt65k_syscalls_files")
combined_syscalls_dir_path_Path = Path(PROJECT_ROOT, "C:\\Code\\miller\\data\\behaviour_files_cuckoofork")
limit_reports_files = None
limit_syscalls_length = 500


def process_reports_file(dict_manager, file_name, logger):
    try:
        lines = open(file=combined_syscalls_dir_path_Path / file_name, mode='rb').readlines()
        for line in lines:
            try:
                cuckoo_report = json.loads(line.decode(encoding="UTF-8", errors='replace'))
                max_calls = max(len(pid_dict['calls']) for pid_dict in cuckoo_report['behavior']['processes'])
                if limit_syscalls_length > max_calls:
                    continue
                sha256 = cuckoo_report['sha256']
                syscalls_file_Path = combined_syscalls_dir_path_Path / "flatten" / sha256
                if os.path.isfile(syscalls_file_Path):
                    continue
                with open(file=syscalls_file_Path, mode='w', encoding="utf8") as syscalls_file:
                     json.dump(cuckoo_report, syscalls_file)
            except json.JSONDecodeError as err:
                print("process report {0}   JSONDecodeError error: {1}".format(sha256, err))
                pass
            except:
                print("process_reports_file: {0}, error: {1}".format(file_name, sys.exc_info()))
                pass
    except IOError as err:
        print("process_reports_file   I/O error: {0}".format(err))
    except:
        print("process_reports_file: {0}, error: {1}".format(file_name, sys.exc_info()))



def main():
    if not os.path.exists(output_dir_path_Path):
        os.makedirs(output_dir_path_Path)
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s [%(threadName)-12.12s] [%(levelname)-5.5s]  %(message)s",
        handlers=[
            logging.FileHandler(os.path.join(output_dir_path_Path, "log.txt")),
            logging.StreamHandler(sys.stdout)
        ])
    logger = logging.getLogger()
    logger.info("main func start, print arguments for this run:")

    with multiprocessing.Manager() as manager:
        dict_manager = manager.dict()
        cpu_cores = 1
        if sys.platform == 'linux':
            # check avail cpu cores - only-Linux!
            cpu_cores = len(os.sched_getaffinity(0))
        else:
            # check CPU cores number - multi-platform
            cpu_cores = multiprocessing.cpu_count()
        starttime = time.time()
        num_processes = cpu_cores
        multiprocessing.freeze_support()
        with multiprocessing.Pool(num_processes) as pool:

            try:
                map_func = pool.apply_async
                a_results = [map_func(func=process_reports_file, args=(dict_manager, file_name, logger))
                             for file_name in
                             itertools.islice(os.listdir(combined_syscalls_dir_path_Path), 0, limit_reports_files)]
                pool.close()
                pool.join()
            except:
                logger.info("---- main loop error ----")
                logger.info(sys.exc_info)
                sys.exit(1)


        logger.info('That took {} seconds'.format(time.time() - starttime))
        dict_manager_file_path = os.path.join(output_dir_path_Path, "dict.json")
        with open(dict_manager_file_path, 'w') as output_file:
            json_dict = json.dumps(dict_manager.copy(), ensure_ascii=False)
            output_file.write(json_dict)  # .encode("utf-16"))

        logger.info("finished run, resulted dict in: " + dict_manager_file_path)

if __name__ == '__main__':
    try:
        main()
    except Exception as ex:
        print(ex)
        sys.exit(1)

