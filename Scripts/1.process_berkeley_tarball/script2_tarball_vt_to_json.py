import itertools
import multiprocessing as mp
import csv
import sys
import argparse
import os
import json
import pickle
import datetime
import shutil
import datetime
import multiprocessing
import time
import logging
from pathlib import Path

PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))
output_dir_path_Path = Path(PROJECT_ROOT, "output")
syscalls_dir_path_Path = Path(PROJECT_ROOT, "vt65k_syscalls_files")
vt_dir_path_Path = Path(PROJECT_ROOT, "C:\\Code\\miller\\data\\reports_files_VT")
limit_reports_files = None


def get_virustotal_result(report_blob):
    virustotal_report = json.loads(report_blob.decode(encoding="UTF-8", errors = 'replace'))
    score = float(virustotal_report["positives"]) / float(virustotal_report["total"])
    score *= 10
    first_seen_str = virustotal_report["first_seen"] 
    first_seen_obj = datetime.datetime.strptime(first_seen_str, '%Y-%m-%d %H:%M:%S') # "first_seen": "2018-03-13 19:53:23"
    sha256 = virustotal_report['sha256']
    return score, first_seen_obj, sha256


def process_reports_file(dict_manager, file_name, logger):
    try:
        lines = open(file=vt_dir_path_Path / file_name, mode='rb').readlines()
        for line in lines:
            score, first_seen_obj, sha256 = get_virustotal_result(line)
            logger.info("score: " + str(score) + "   first_seen_obj to str: " + str(first_seen_obj.strftime("%Y-%m")))
            dict_manager[sha256] = {
                "score": str(score),
                "first_seen_obj": str(first_seen_obj.strftime("%Y-%m"))
            }
    except IOError as err:
        print("process_reports_file   I/O error: {0}".format(err))
    except:
        print("process_reports_file: {0}, error: {1}".format(file_name, sys.exc_info()))


def main():
    if not os.path.exists(output_dir_path_Path):
        os.makedirs(output_dir_path_Path)
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s [%(threadName)-12.12s] [%(levelname)-5.5s]  %(message)s",
        handlers=[
            logging.FileHandler(os.path.join(output_dir_path_Path, "log.txt")),
            logging.StreamHandler(sys.stdout)
        ])
    logger = logging.getLogger()
    logger.info("main func start, print arguments for this run:")

    with multiprocessing.Manager() as manager:
        dict_manager = manager.dict()
        cpu_cores = 1
        if sys.platform == 'linux':
            # check avail cpu cores - only-Linux!
            cpu_cores = len(os.sched_getaffinity(0))
        else:
            # check CPU cores number - multi-platform
            cpu_cores = multiprocessing.cpu_count()
        starttime = time.time()
        num_processes = cpu_cores
        multiprocessing.freeze_support()
        with multiprocessing.Pool(num_processes) as pool:

            try:
                map_func = pool.apply_async
                a_results = [map_func(func=process_reports_file, args=(dict_manager, file_name, logger))
                             for file_name in
                             itertools.islice(os.listdir(vt_dir_path_Path), 0, limit_reports_files)]
                pool.close()
                pool.join()
            except:
                logger.info("---- main loop error ----")
                logger.info(sys.exc_info)
                sys.exit(1)

        logger.info('That took {} seconds'.format(time.time() - starttime))

        dict_manager_file_path = os.path.join(output_dir_path_Path, "labels.json")
        with open(dict_manager_file_path, 'w') as output_file:
            json_dict = json.dumps(dict_manager.copy(), ensure_ascii=False)
            output_file.write(json_dict)  # .encode("utf-16"))

        logger.info("finished run, resulted dict in: " + dict_manager_file_path)

if __name__ == '__main__':
    try:
        main()
    except Exception as ex:
        print(ex)
        sys.exit(1)


## for future weighted-scoring, a list of all VT-AVs is attached:
# VIRUSTOTAL_AVS = {
#     "Bkav": 1.0,
#     "MicroWorld-eScan": 1.0,
#     "CMC": 1.0,
#     "CAT-QuickHeal": 1.0,
#     "McAfee": 1.0,
#     "Cylance": 1.0,
#     "Zillya": 1.0,
#     "AegisLab": 1.0,
#     "TheHacker": 1.0,
#     "K7GW": 1.0,
#     "K7AntiVirus": 1.0,
#     "TrendMicro": 1.0,
#     "Baidu": 1.0,
#     "NANO-Antivirus": 1.0,
#     "F-Prot": 1.0,
#     "Symantec": 1.0,
#     "TotalDefense": 1.0,
#     "TrendMicro-HouseCall": 1.0,
#     "Avast": 1.0,
#     "ClamAV": 1.0,
#     "GData": 1.0,
#     "Kaspersky": 1.0,
#     "BitDefender": 1.0,
#     "Babable": 1.0,
#     "ViRobot": 1.0,
#     "Rising": 1.0,
#     "Ad-Aware": 1.0,
#     "Sophos": 1.0,
#     "Comodo": 1.0,
#     "F-Secure": 1.0,
#     "DrWeb": 1.0,
#     "VIPRE": 1.0,
#     "Invincea": 1.0,
#     "McAfee-GW-Edition": 1.0,
#     "Emsisoft": 1.0,
#     "Ikarus": 1.0,
#     "Cyren": 1.0,
#     "Jiangmin": 1.0,
#     "Webroot": 1.0,
#     "Avira": 1.0,
#     "MAX": 1.0,
#     "Antiy-AVL": 1.0,
#     "Kingsoft": 1.0,
#     "Endgame": 1.0,
#     "Arcabit": 1.0,
#     "SUPERAntiSpyware": 1.0,
#     "ZoneAlarm": 1.0,
#     "Avast-Mobile": 1.0,
#     "Microsoft": 1.0,
#     "AhnLab-V3": 1.0,
#     "ALYac": 1.0,
#     "AVware": 1.0,
#     "TACHYON": 1.0,
#     "VBA32": 1.0,
#     "Malwarebytes": 1.0,
#     "Panda": 1.0,
#     "Zoner": 1.0,
#     "ESET-NOD32": 1.0,
#     "Tencent": 1.0,
#     "Yandex": 1.0,
#     "SentinelOne": 1.0,
#     "eGambit": 1.0,
#     "Fortinet": 1.0,
#     "AVG": 1.0,
#     "Cybereason": 1.0,
#     "Paloalto": 1.0,
#     "CrowdStrike": 1.0,
#     "Qihoo-360": 1.0
# }